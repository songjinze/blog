---
title: 正则表达式
tags: 算法
categories: 算法
date: 2019-07-29 23:04:12
---


## 正则表达式

### 1. 描述模式

#### 1.1 连接

当我们写出AB时，就制定了一种语言{AB}。它含有两个字符组成的字符串，由A和B连接而成。

#### 1.2 或操作

第二种操作可以在模式中指定多种可能的匹配。用“|”表示这个操作。例如，A|B指定的语言是{A,B}，A|E|I|O|U指定的语言是{A,E,I,O,U}。连接操作的优先级高于或操作。因此AB|BCD的指定语言是{AB,BCD}。

#### 1.3 闭包操作

第三种操作是可以将模式的部分重复任意的次数。我们将“\*”标记在需要被重复的模式之后，以表示闭包。闭包操作的优先级高于连接操作，因此AB\*指定的语言是由一个A和0~多个B的字符串组成。

#### 1.4 括号

使用括号来改变默认的优先级顺序。

### 2. 定义

一个正则表达式可以是：
* 空字符串ε
* 单个字符
* 包含在括号中的另一个正则表达式
* 两个或多个连接起来的正则表达式
* 由或运算符分隔的两个或多个正则表达式
* 由闭包运算标记的一个正则表达式

每个正则表达式表示的都是一个字符串的集合：
* 空正则表达式表示的字符串的集合为空，含有0个元素
* 一个字符表示的字符串的集合含有一个元素，即该字符本身
* 一个由括号和包含在其中的正则表达式组成的正则表达式表示的字符串的集合与括号内的正则表达式相同
* 由两个正则表达式连接起来的正则表达式表示的字符串的集合为这两个正则表达式分别表示的字符串集合的叉乘。（按照正则表达式中指定的顺序，由一个字符串集合中的元素和另一个字符串集合中的元素相连接所能够组合而成的所有字符串）
* 由或运算符连续的两个正则表达式所表示的字符串的集合为两个正则表达式分别表示的字符串集合的并集
* 由一个正则表达式的闭包所表示的字符串的集合由ε（空字符串）或将被修饰的正则表达式所表示的字符串集合重复任意次所得到的所有字符串所组成

字符串描述符：
|名称|记法|举例|
|---|---|---|
|通配符|.|A.B|
|指定的集合|包含在\[\]中的字符|\[AEIOU\]\*|
|范围集合|包含在\[\]中，由"-"分隔|\[A-Z\]\[0-9\]|
|补集|包含在\[\]中，首字母为"^"|\[AEIOU\]\*|

闭包的简写（指定操作数的重复次数）：
|选项|记法|举例|
|---|---|---|
|至少重复1次|+|(AB)+|
|重复0或1次|?|(AB)?|
|重复指定次数|由{}指定次数|(AB){3}|
|重复指定范围的次数|由{}指定范围|(AB){1-2}|

### 3. 实际应用

|应用场景|正则表达式|
|---|---|
|电话号码|```\([0-9]{3}\) [0-9]{3}-[0-9]{4}```|
|Java标识符|```[$_A-Za-z][$_A-Za-z0-9]*```|
|基因组|```gcg(cgg|agg)*ctg```|
|电子邮件地址|```[a-z]+@([a-z]+\.)+(edu|com)```|

### 4. 非确定有限状态自动机

#### 4.1 NFA介绍

从示例入手：我们先判断一个文本是否包含正则表达式((A*B|AC)D)所描述的语言之中。我们所定义的NFA有着以下特点：

* 长度为M的正则表达式中的每个字符在所对应的NFA中都有且只有一个对应的状态。NFA的起始状态为0并含有一个（虚拟的）接受状态M。
* 字母表中的字符所对应的状态都有一条从它指出的边，这条边指向模式中的下一个字符所对应的状态（图中的黑色的边）。
* 元字符“\(”、“\)”、“|”和“\*”所对应的状态至少含有一条指出的边（图中的红色的边），这些边可能指向其他的任意状态。
* 有些状态有多条指出的边，但一个状态只能有一条指出的黑色边。

{% asset_img NFA.PNG NFA %}

约定将所有的模式都包含在括号中，因此NFA中的第一个状态对应的是左括号，而最后一个状态对应的是右括号（并能够转换为接受状态）。

#### 4.2 模拟NFA的运行

```java
public boolean recognizes(String text){
    // NFA是否能够识别文本txt？
    Bag<Integer> pc = new Bag<Integer>();
    DirectedDFS dfs = new DirectedDFS(G, 0);
    for(int v = 0; v < G.V(); v++){
        if(dfs.marked(V)) pc.add(v);
    }
    for(int i = 0; i < txt.length(); i++){
        //计算txt[i+1]可能到达的所有NFA状态
        Bag<Integer> match = new Bag<Integer>();
        for(int v : pc){
            if(v < M){
                if(re[v] == txt.charAt(i) || re[v] == '.'){
                    match.add(v+1);
                }
            }
        }
        pc = new Bag<Integer>();
        dfs = new DirectedDFS(G, Match);
        for(int v = 0; v < G.V(); v++){
            if(dfs.marked(v)) pc.add(v);
        }
    }
    for(int v : pc) if(v == M) return true;
    return false;
}
```

#### 构造与正则表达式对应的DFA

```java
public  class NFA{
    private char[] res;     //匹配转换
    private Digraph G;      //epsilon转换
    private int M;          //状态数量

    public NFA(String regexp){
        //根据给定的正则表达式构造NFA
        Stack<Integer> ops = new Stack<Integer>();
        re = regexp.toCharArray();
        M = re.length;
        G = new Digraph(M + 1);
        for(int i = 0; i < M; i++){
            int lp = i;
            if(re[i] == '(' || re[i] == '|'){
                ops.push(i);
            }else if(re[i] == ')'){
                int or = ops.pop();
                if(re[or] == '|'){
                    lp = ops.pop();
                    G.addEdge(lp, or + 1);
                    G.addEdge(or, i);
                }
                else lp = or;
            }
            if(i < M - 1 && re[i + 1] == '*')  //查看下一个字符
            {
                G.addEdge(lp, i + 1);
                G.addEdge(i + 1, lp);
            }
            if(re[i] == '(' || re[i] == '*' || re[i] == ')'){
                G.addEdge(i, i + 1);
            }
        }
    }

    public boolean recognizes(String txt); //见上文
}
```

{% asset_img 构建DFA.PNG 构建DFA %}

