---
title: 乐观锁和悲观锁
tags: 计算机原理
categories: 计算机原理
date: 2019-03-07 00:37:05
---


## 乐观锁和悲观锁

用大白话来说，并发问题一个原因是因为不同的线程共享相同数据，因此一个线程在执行一系列操作时不能保证使用的数据不发生改变。针对这个问题，我们需要对共享数据使用锁机制。从性能上来考虑，频繁的读和频繁的写应该使用不同的锁机制来控制。一般来说**乐观锁适合频繁读，悲观锁适合频繁写。**

### 什么是乐观锁和悲观锁？

从字面上意思其实就可以很好地说明。乐观锁对于情况较为乐观，希望事情向好的方向发展。而悲观锁则认为事情会向坏的方向发展。悲观锁和乐观锁本质上是一种思想，并不是数据库特有的机制。

### 悲观锁

悲观锁每次都假设是最坏的情况，每次拿数据都会认为别人可能会进行修改，所以每次都会先上锁，这样在别人拿数据时就会阻塞。传统的关系型数据库许多锁（比如行锁、表锁、读锁、写锁等）就是在操作之前先上锁。java的synchronized就是悲观锁。

### 乐观锁

乐观锁每次假设拿数据时不会有人来修改，所以每次乐观锁在读数据时不会上锁。乐观锁的实现可使用**版本号机制**或**CAS算法Compare And Swap**来实现。

### 关于版本号机制

版本号机制其实是使用一个专门标识“是否被修改”的变量来解决并发问题。
```
int volatile version=0; //版本号，可以默认初始为0
operation(){
    version++;
    int tempVersion=version;
    //进行一系列操作
    update();
}
// 应该保证一个更新的原子操作
synchronized update(){
    //更新数据
    if(version==tempVersion){
        update();
    }
    else{
        //重新operation
    }
}
```
这种写法可以保证在进行一系列操作时可以预测到数据的改变。当然update如果过大的话仍然无法保证性能。就如上文所说，频繁的写操作在乐观锁中性能很低。

### 关于CAS算法

CAS算法就是比较和交换的意思。算法特点是**如果有多个线程同时在更新一个变量时，应该只会有一个线程能够成功更新。**  
算法思想可以说是，如果想修改的值不再是原来的值，那么就不应该修改它。“我认为V值为A，如果是，那么将V更新为B”

```
oldData,newData,target_ptr;
operation(){
    copyOldData=*target_ptr;
    //进行一系列操作获得newData
    cas(copyOldData,newData,target_ptr)
}
synchronized cas(oldData,newData,*target_ptr){
    if(oldData==*target_ptr){
        //想修改的数据是原来的数据
        *target_ptr=newData;
    }
    //否则回滚，放弃修改并将原来的值还原。
    return oldData;
}
```

CPU指令在大多数处理器架构，包括IA32、Space中采用的都是CAS指令。