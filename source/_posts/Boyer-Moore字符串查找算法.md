---
title: Boyer-Moore字符串查找算法
tags: 算法
categories: 算法
date: 2019-06-13 00:20:04
---


## Boyer-Moore字符串查找算法

我们在KMP字符串匹配算法中描述了如何用回退的方法来匹配字符串。  
当可以在文本字符串中回退时，如果可以从右向左扫描模式字符串并将它和文本匹配，那么就能得到一种非常快的字符串查找算法。和KMP子字符串查找算法的实现一样，我们会根据匹配失败时的文本和模式中的字符串来决定下一步的行动。这就需要预处理，目的在于判断对于文本中可能出现的每一个字符，在匹配失败时算法应该怎么办。

### 启发式的处理不匹配的字符

例如：  
文本：**F I N D I N A H A Y S T A C K N E E D L E**  
模式：**N E E D L E**  
匹配步骤如下：  

1. 比较模式字符串中E和5位置的N，因为N也出现在了模式字符串中，所以将模式字符串向右移动5个位置，将文本字符N和模式中字符N对应。
2. 比较模式字符串中E和10位置的S，匹配失败。因为S不包含在模式字符串中，因此将模式字符串向右移动6个位置（因为模式字符串中没有字符与S对齐）。
3. 比较模式字符串中E和16位置E，匹配。再比较模式字符串中L和15位置N，匹配失败，再将模式字符串向右移动4个位置与N对齐。
4. 比较模式字符串中所有位置发现均匹配，则匹配成功。  

至此我们发现，这种方法匹配位置仅用了4次字符比较（以及6次比较来验证匹配）。

{% asset_img 从右向左.PNG 从右向左启发式地查找字符串 %}

### 前期准备

我们使用一个数组right\[\]记录字母表中每个字符再模式中出现的*最靠右*的地方（如果字符在模式中不存在则表示为-1。这个值表示了如果该字符出现在文本中且在查找时造成了一次匹配失败，应该向右跳多远。  
先将right\[\]初始化所有元素置为-1，然后对于0到M-1的j，将right\[pat.charAt(j)\]置为j。

### 算法思想

用索引i在文本中从左到右移动，用另一个索引j在模式中从右向左移动。如果从M-1到0的所有j，txt.charAt(i+j)都和pat.charAt(j)相等，那么就找到了一个匹配。否则匹配失败，失败时为以下三种情况：
1. 造成匹配失败的字符不在模式字符串中，模式字符串向右移动j+1个位置。
2. 如果匹配失败的字符包含在模式字符串中，那就可以使用right[]数组来将模式字符串和文本对齐。
3. 如果这种方式无法增大i，那就直接将i加1来保证模式字符串至少向右移动了一个位置。

### 算法实现

```java
public class BoyerMoore
{
    private int[] right;
    private String pat;
    BoyerMoore(String pat)
    {
        //计算跳跃表
        this.pat = pat;
        int M = pat.length();
        int R = 256;
        right = new int[R];                                     //不包含在模式字符串中的字符的值为-1
        for(int c = 0; c < R; c++)  right[c] = -1;              //包含在模式字符串中的字符的值为
        for(int j = 0; j < M; j++)  right[pat.charAt(j)] = j;   //它在其中出现的最右位置
    }

    public int search(String txt)
    {
        //在txt中查找模式字符串
        int N = txt.length();
        int M = pat.length();
        int skip;
        for(int i = 0; i <= N - M; i += skip)
        {
            //模式字符串和文本在位置i是否匹配
            skip = 0;
            for(int j = M - 1; j >= 0; j--)
            {
                if(pat.charAt(j) != txt.charAt(i + j))
                {
                    skip = j - right[txt.charAt(i + j)];
                    if(skip < 1) skip = 1;
                    break;
                }
            }
            if(skip == 0) return i;                             //找到匹配
        }
        return N;                                               //未找到匹配
    }
}
```

### 性能分析

* 在一般情况下，对于长度为N的文本和长度为M的模式字符串，使用了Boyer-Moore的子字符串查找算法通过启发式处理不匹配的字符需要~N/M次字符比较。