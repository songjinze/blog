---
title: 单词查找树
tags: 算法
categories: 算法
---

# 单词查找树

* 查找命中所需的时间与被查找的键的长度成正比
* 查找未命中只需检查若干个字符

## 基于单词查找树的符号表

```java
public class TrieST<Value>
{
    private static int R=256;
    private Node root;

    private static class Node{
        private Object va;
        private Node[]next=new Node[R];
    }

    public Value get(String key){
        Node x=get(root,key,0);
        if(x==null) return null;
        return (Value)x.val;
    }

    private Node get(Node x,String key,int d){
        //返回x作为根节点的子单词查找树中与key相关联的值
        if(x==null) return null;
        if(d==key.length()) return x;
        char c=key.charAt(d);  //找到第d个字符所对应的子单词查找树
        return get(x.next[c],key,d+1);
    }

    public void put(String key,Value val){
        root=put(root,key,val,0);
    }

    private Node put(Node x,String key,Value val,int d){
        //如果Key存在于以x为根节点的子单词查找树中则更新与它相关联的值
        if(x==null) x=new Node();
        if(d==key.length()){
            x.val=val;
            return x;
        }
        char c=key.charAt(d);  //找到第d个字符所对应的子单词查找树
        x.next[c]=put(x.next[c],key,val,d+1);
        return x;
    }
}
```

## 查找所有键

收集一棵单词查找树中所有的键。

```java
public Iterable<String> keys(){
    return keysWithPrefix("");
}
public Iterable<String>keysWithPrefix(String pre){
    Queue<String>q=new Queue<String>();
    collect(get(root,pre,0),pre,q);
    return q;
}
private void collect(Node x,String pre,Queue<String>q){
    if(x==null) return;
    if(x.val!=null) q.enqueue(pre);
    for(char c=0;c<R;c++){
        collect(x.next[c],pre+c,q);
    }
}
```

## 通配符匹配

单词查找树中的通配符匹配。

```java
public Iterable<String> keysThatMatch(String pat){
    Queue<String>q=new Queue<String>();
    collect(root,"",pat,q);
    return q;
}
public void collect(Node x,String pre,String pat,Queue<String>q){
    int d=pre.length();
    if(x==null) return;
    if(d==pat.length()&&x.val!=null) q.enqueue(pre);
    if(d==pat.length()) return;

    char next=pat.charAt(d);
    for(char c=0;c<R;c++){
        if(next=='.'||next==c){
            collect(x.next[c],pre+c,pat,q);
        }
    }
}
```

## 最长前缀

对给定字符串的最长前缀进行匹配。

```java
public String longestPrefixOf(String s){
    int length=search(root,s,0,0);
    return s.substring(0,length);
}

private int search(Node x,String s,int d,int length){
    if(x==null) return length;
    if(x.val!=null) length=d;
    if(d==s.length()) return length;
    char c=s.charAt(d);
    return search(x.next[c],s,d+1,length);
}
```

## 删除操作

从单词查找树中删除一个键（和它相关联的值）。

```java
public void delete(String key){
    root=delete(root,key,0);
}

private Node delete(Node x,String key,int d){
    if(x==null) return null;
    if(d==key.length()){
        x.val=null;
    }
    else{
        char c=key.charAt(d);
        x.next[c]=delete(x.next[c],key,d+1);
    }
    if(x.val!=null) return x;
    for(char c=0;c<R;c++){
        if(x.next[c]!=null) return x;
    }
    return null;
}
```

## 单词查找树的性质

* 单词查找树的链表结构（形状）和键的插入或删除顺序无关：对于给定的任意的一组键，其单词查找树都是唯一的。
* 在单词查找树中查找一个键或是插入一个键时，访问数组的次数最多的键的长度加1。
* 字母表的大小为R，在一棵由N个随机键构造的单词查找树中，未命中查找平均所需检查的结点数量为~log<sub>R</sub>N
