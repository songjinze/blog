---
title: java垃圾收集与内存分配
tags: Java
categories: Java
---

## java垃圾收集与内存分配

### 1 垃圾回收算法

#### 1.1 引用计数法


引用计数法算法比较好理解。如果一个对象A被另一个对象B引用，且对象B没有成为被回收对象，则这个对象A不会被回收。  
引用计数的问题是需要解决循环引用的问题。比如一段代码：

```java
A a = new A();
B b = new B();
a.instance = b;
b.instance = a;
a = null;
b = null;
System.gc();
```

这个时候a、b实际上都应该被回收，其实在jvm中a、b是会被回收成功的。但单纯根据引用计数法来说，a、b不会被回收。因此可见，jvm中使用的不是单纯的引用计数法。

#### 1.2 根搜索算法

根搜索算法的基本思路是通过一系列GC Roots对象作为起点，向下搜索，走过的路径称为一条引用链。从图的角度，最后生成一个有向图。  
从图的角度，对于那些从GC Root开始不可达的节点，将会被作为垃圾回收的对象。  
值得说明的是，这里回收的并不是说没有任何引用关系的孤立节点，实际上那些与GC Root不连通的图，整图都作为垃圾回收的对象。

Java语言中，以下类型的对象可以作为GC对象：
* 虚拟机栈（栈中局部变量表）中引用的对象
* 方法区中类的静态属性引用的对象
* 本地方法栈中（native）引用的对象
* 方法区中的常量引用的对象

##### 1.2.1 finalize()方法

> finalize()方法在9版本之后不赞成使用。

finalize()方法是Object类中的方法。一个对象在生命周期中**只能执行一次**finalize()方法。</br>
一个对象被判定为有必要执行finalize()方法时，首先会被放在一个名为F-Queue的队列中。稍后被由一条虚拟机自动建立的，低优先级的Finalizer线程去执行。  
finalize()可以理解为对象逃脱被收集的最后挣扎。因此finalize()方法有几个特点：
* 虚拟机触发finalize()方法不会因此而阻塞。比如在finalize()中陷入死循环，整个F-Queue队列不会因此等待。
* 如果对象要在垃圾回收中拯救自己，需要在finalize()方法中使自己与引用链上的对象建立关联。
* finalize()只会被执行一次，意味着执行后的对象在下次回收时不会与第一次有相同的结果。

最后，finalize()实际上是java诞生时为了妥协C/C++程序员的产物（虽然不是，但是看起来很像析构函数）。因此这个方法应该被我们忘记。

##### 1.2.2 根搜索算法的二次标记

前文提到，根搜索算法会根据是否与GC Root有相连的引用链来进行回收。但实际上并不是直接回收，而是一个**二次标记**的过程。一个对象从标记到被回收需要经历以下过程：

1. 根搜索算法后发现没有与GC Root相连的引用链，被第一次标记。
2. 对象会被筛选，条件为是否有必要执行finalize()方法。不满足条件的会被回收。
3. 如果满足2中条件，则会被放入队列执行finalize()方法。稍后队列中的对象会被进行第二次标记。如果对象没有“自我拯救”成功，则会被回收。

### 2 java引用类型

在JDK1.2之后，java对引用进行了扩充，引用分为四种：
* 强引用（Strong Reference） 实现方法为Object a = new Object();
* 软引用（Soft Reference） 实现方法为SoftReference类。
* 弱引用（Weak Reference） 实现方法为WeakReference类。
* 虚引用（Phantom Reference） 实现方法为PhantomReference类。

#### 2.1 强引用

强引用是代码中最明显的部分。Object a = new Object();就是一个强引用声明和创建对象。

#### 2.2 软引用

软引用描述还有用，但不是必需的对象。  
对于软引用的对象，在系统将要发生内存溢出之前，将会把这些对象进行二次回收。如果回收后还不够足够的内存，才会抛出系统内存溢出异常。

#### 2.3 弱引用

弱引用描述非必需对象。  
与软引用不同的是，弱引用更弱，它只存活到下一次垃圾回收发生之前。也就是说无论内存是否足够，都会回收掉被弱引用关联的对象。

#### 2.4 虚引用

虚引用实际上不会对垃圾回收机制产生影响，所以不会对对象生存时间产生影响，也无法通过虚引用获得对象的实例。</br>
虚引用的作用在于，可以在对象被垃圾回收的时候设置类似系统通知的功能。

### 3 方法区的回收

从分代角度来讲，垃圾回收在永久代回收的内容很少，而在新生代老生代之间的回收算是我们日常考虑的角度。  
但实际上，永久代的垃圾回收也是存在。一般回收两部分：

1. 废弃常量。
2. 无用的类。

比如典型的字符串常量"abc"，通常在某一时刻被创建并放入常量池中，而后当系统中没有一个字符串对象叫"abc"时，这个常量会被回收。</br>
无用的类这个判定比较复杂，什么样的类才能从方法区中被回收掉，需要同时满足这些条件：
* 类实例已经全部被回收
* 加载该类的ClassLoader被回收
* 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

满足这些条件，虚拟机可以回收这样的“无用的类”，当然，具体会不会回收还是要看虚拟机的具体实现，不会像对象回收那么严格。

### 4 垃圾收集算法

* 新生代一般使用复制算法
* 老生代一般使用标记-整理算法

#### 4.1 标记-清除算法

标记-清除算法可以认为是最基础的收集算法。算法步骤分为两步：
1. 标记
2. 清除

可以理解为