---
title: java内存模型
tags: Java
categories: Java
---

## java内存模型简述

### 1 运行时数据区域

{% asset_img 内存模型.jpg 内存模型 %}

#### 1.1. 程序计数器

* 线程私有
* 内存空间较小
* 不会发生OutOfMemoryError

程序计数器内存空间较小，与操作系统中的pc一样，jvm中的程序计数器可以看作是当前线程所执行的字节码的行号指示器，简单地说就是指向了当前线程执行到了哪里。每个线程都有一个独立的程序计数器，各个线程之间的程序计数器互不影响。  
值得注意的是，如果线程正在执行一个java中的方法，计数器记录的是正在执行的虚拟机中字节码指令的地址；如果正在执行的是一个native方法，则计数器值为空（undefined）。这块内存区域不会内存泄漏。

#### 1.2 java虚拟机栈

* 线程私有，生命周期与线程相同
* 如果线程申请的栈深度大于虚拟机允许最大深度，会抛出StackOverflowError异常
* 在虚拟机允许动态扩展栈深度的同时，如果线程申请的栈深度过大，无法申请到足够的内存，则会抛出OutOfMemoryError

java虚拟机栈体现了java方法执行时的内存模型。方法被执行的时候，会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等。一个方法被调用并被执行的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。  
局部变量表存放了基本数据类型、对象引用和returnAddress（即方法返回地址）。如果机器是32位，long和double会占用两个局部变量空间。局部变量表所需大小在编译时分配，在运行时为方法分配的局部变量空间是确定的。  

#### 1.3 本地方法栈

实际上本地方法栈与java虚拟机栈的不同是，本地方法栈为native方法服务，本地方法栈中使用的方法没有限制，这里只是一个规范，设计虚拟机的人可以自己自由实现。

#### 1.4 java堆

* 理论上存放对象实例及数组，但随着优化技术成熟这个理论不绝对
* 是垃圾回收器的主要管理区域
* 线程共享，但从垃圾回收角度可以划分出多个线程私有的缓冲区

这里我们不讨论java的垃圾回收机制。java堆物理上不一定是连续的空间，但在逻辑上是一大块连续的逻辑空间。如果堆中没有内存完成实例分配，也无法再扩展时，会抛出OutOfMemoryError异常。

#### 1.5 方法区

* 线程共享
* 虽然是堆的一个逻辑部分，但别名非堆（Non-Heap），与堆区分开。
* 可以选择不实现垃圾回收，有人愿意将其称为“永久代”

方法区存放已被虚拟机加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据。与堆一样，不需要连续的内存，也可以选择固定大小或可扩展。无法满足内存分配需求时，会抛出OutOfMemoryError异常。


#### 1.6 运行时常量池

* 是方法区的一部分
* 注意区分class文件中的常量池和java虚拟机中的运行时常量池，虽然class文件中的常量池内容也放入运行时常量池中。

class文件中有除了版本、字段、方法、接口等，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这些内容在类加载之后存放到方法区的运行时常量池中。  
运行时常量池相对于class文件中的常量池，最重要的区别是动态性，java语言并不要求常量一定只能在编译期产生，运行期间也可以将新的常量放入池中。  
无法满足内存分配需求时，会抛出OutOfMemoryError异常。

#### 1.7 直接内存

* 不是虚拟机运行时数据区的一部分，没有被虚拟机规范定义
* 可能导致OutOfMemoryError异常

将直接内存这个概念分出来是因为直接内存在新版本的java中，实际上作为一种优化方式与虚拟机有联系。
NIO（New Input/Output）类，引入了通道与缓冲区的IO方式，可以使用native函数库直接分配堆外内存，在堆中保存相应的对象作为这块内存的引用进行操作。

### 2 java对象访问

比如java中有一个类A，类存在默认构造函数，写一段代码如下：

```java
A a = new A();
```

等式左边声明了对象A的引用a，这会反映到java栈的局部变量表中，等式右边new A()则会反映到java堆中，形成了一块存储A类型的所有实例数据值（指的是对象中各个实例字段的数据）。此时的局面为：

* 本地方法栈的局部变量表中，存放了一个A对象的reference类型a
* 堆中存放了对象实例数据
* 方法去存放了对象类型数据

那么在局部变量表中拿到了对象引用后，如何定位并在堆、方法区中拿到想要的数据？这里介绍两种方式：句柄和直接指针。注意，不同的实现方式需要在虚拟机的实现上体现，java虚拟机规范中并没有规定如何实现。

#### 2.1 句柄访问方式

这种方式java堆中会划分出一块内存作为句柄池，reference中存储的对象是句柄地址，句柄包含了对象实例数据和对象类型数据。

{% asset_img 句柄方式访问对象.jpg 句柄方式 %}

句柄方式的好处是对象被移动的时候（比如垃圾回收时），只需在堆中修改句柄内实例数据的指针，而不用在局部变量表中修改reference。

#### 2.2 直接指针方式

这种方式java堆中只需考虑如何放置访问对象类型数据的相关信息。reference中直接存储的是堆中对象地址。

{% asset_img 直接指针方式访问对象.jpg 直接指针方式 %}

直接指针访问相比句柄，节省了一次指针定位的时间开销。